// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    AUTO GENERATED CODE     ***
//
// ----------------------------------------------------------------------------
//
//     This file is automatically generated by Config Connector and manual
//     changes will be clobbered when the file is regenerated.
//
// ----------------------------------------------------------------------------

// *** DISCLAIMER ***
// Config Connector's go-client for CRDs is currently in ALPHA, which means
// that future versions of the go-client may include breaking changes.
// Please try it out and give us feedback!

package v1beta1

import (
	"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/clients/generated/apis/k8s/v1alpha1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

type RecordsetGeo struct {
	/* The location name defined in Google Cloud. */
	Location string `json:"location"`

	// +optional
	RrdatasRefs []RecordsetRrdatasRefs `json:"rrdatasRefs,omitempty"`
}

type RecordsetRoutingPolicy struct {
	/* Specifies whether to enable fencing for geo queries. */
	// +optional
	EnableGeoFencing *bool `json:"enableGeoFencing,omitempty"`

	/* The configuration for Geo location based routing policy. */
	// +optional
	Geo []RecordsetGeo `json:"geo,omitempty"`

	/* The configuration for Weighted Round Robin based routing policy. */
	// +optional
	Wrr []RecordsetWrr `json:"wrr,omitempty"`
}

type RecordsetRrdatasRefs struct {
	/* Allowed value: The `address` field of a `ComputeAddress` resource. */
	// +optional
	External *string `json:"external,omitempty"`

	/* Kind of the referent. Allowed values: ComputeAddress */
	// +optional
	Kind *string `json:"kind,omitempty"`

	/* Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names */
	// +optional
	Name *string `json:"name,omitempty"`

	/* Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/ */
	// +optional
	Namespace *string `json:"namespace,omitempty"`
}

type RecordsetWrr struct {
	// +optional
	RrdatasRefs []RecordsetRrdatasRefs `json:"rrdatasRefs,omitempty"`

	/* The ratio of traffic routed to the target. */
	Weight float64 `json:"weight"`
}

type DNSRecordSetSpec struct {
	ManagedZoneRef v1alpha1.ResourceRef `json:"managedZoneRef"`

	/* Immutable. The DNS name this record set will apply to. */
	Name string `json:"name"`

	/* The configuration for steering traffic based on query. You can specify either Weighted Round Robin(WRR) type or Geolocation(GEO) type. */
	// +optional
	RoutingPolicy *RecordsetRoutingPolicy `json:"routingPolicy,omitempty"`

	/* DEPRECATED. Although this field is still available, there is limited support. We recommend that you use `spec.rrdatasRefs` instead. */
	// +optional
	Rrdatas []string `json:"rrdatas,omitempty"`

	// +optional
	RrdatasRefs []RecordsetRrdatasRefs `json:"rrdatasRefs,omitempty"`

	/* The time-to-live of this record set (seconds). */
	// +optional
	Ttl *int `json:"ttl,omitempty"`

	/* The DNS record set type. */
	Type string `json:"type"`
}

type DNSRecordSetStatus struct {
	/* Conditions represent the latest available observations of the
	   DNSRecordSet's current state. */
	Conditions []v1alpha1.Condition `json:"conditions,omitempty"`
	/* ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource. */
	// +optional
	ObservedGeneration *int `json:"observedGeneration,omitempty"`
}

// +genclient
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

// DNSRecordSet is the Schema for the dns API
// +k8s:openapi-gen=true
type DNSRecordSet struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`

	Spec   DNSRecordSetSpec   `json:"spec,omitempty"`
	Status DNSRecordSetStatus `json:"status,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

// DNSRecordSetList contains a list of DNSRecordSet
type DNSRecordSetList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []DNSRecordSet `json:"items"`
}

func init() {
	SchemeBuilder.Register(&DNSRecordSet{}, &DNSRecordSetList{})
}
